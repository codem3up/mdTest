# Approval Tests
### Team #1

## Approval Tests
This document aims at giving a quick summary of approval Tests, including a basic rundown of how they work, and their purpose.

## What are Approval Tests? 
While there isn't some formal definition for approval testing, The Approval Test website states that Approval tests simplify testing by taking a snapshot of the results, and confirming that they have not changed.   They are essentially an alternative for assertions.

## How do Approval Tests work?
Approval tests work by using something they coin as the "Golden Master paradigm".   Basically how it works is this.  You write code, when you decide that the code works as you intended it to and the results of the code spit out your intended results, you "approve" of that test.   When you approve of the results of the test the results of the test get added to an approved.txt document that is called the golden master document.  This document is used for all future tests.  If the results of a test differ from the golden master document, the tests will fail.  This has the benefit of allowing you to regression test your project.  If the results of your tests changed you know that something internally has changed about your code, and you can either go back and fix your code, or decide that the code still works as intended, and approve of the changes (thus modifying your golden master document).   There are various ways that you can use approval tests.  One of the simplest and seemingly most used is to override the toString method on an object you're testing.  An example could be a "Person" object.  You could create a Person object, and have the toString method spit out details about this person object.  Then you could call Approvals.verify(person) which would use the toString of the object to spit out the details of the objects state.  After "approving" of the Person object that you're testing, it would add that approved information to the golden master document.  On all future tests, if that object has changed or the toString doesn't match your originally approved results, the tests will fail.

## Why use Approval Tests?
There are a couple of legitimate good reasons to use approval tests.  One of which could be version control.  You could add the golden master approval document to some sort of version control, and in the future - anyone running Approval tests against your code would be required to match that document.  Another good reason for Approval tests is if you're building on top of some sort of legacy application.  Sometimes you don't know the exact details about how/why something works, but you know that it does.  Because it has been well tested and approved, you can have a reasonable amount of assurance that it works, and you can use approval tests to help verify that nothing has changed about the tests that you write.  Another reason that one could use approval tests is for ease of use.  Approval tests are much simpler than assertions, primarily because of the fact that you don't have to write tons of assertions in your methods.  An example of this is when you're approval testing an array.  For instance lets say you have a unit test method that verifies that an array is sorted.  On one hand you could use asserts and verify each individual element in the array is in its correct spot, or you could write an approval test that prints the elements of the array, verify the results of that printed array and add it to your golden master document, and in the future if any of those results changed you would know that your method is no longer working.  This ease of use is a very enticing idea.

## Potential Drawbacks of Approval Tests
Unfortunately there are potential drawbacks of using Approval Tests.  First is that they lack specificity.  Because you essentially approve of the output from a test manually, you don't have to be explicit about the assertions that you are making.  This means that you can get away with testing your program without really verifying all of the specifics.  One of the purposes of Unit testing and assertions is that you must be specific about the exact pieces of a test.  This helps you reason about your code and understand how it works.  Another drawback about Approval tests is that it's not really test driven development.  In (most true) test driven development, you write the tests first, and then you write just enough code to verify that those tests passed.  In the Approval testing paradigm you must first write the code, verify the results, and then authorize that this is the result that you want back from the tests.   It is kind of the opposite of test driven development, because it requires your code to be mostly functional before authorizing that something works.  Another drawback is that you aren't necessarily verifying all of the pieces of your code.  Lets say for instance that you create an object called Person, and that object has many properties.  You then write a custom toString() method that prints the internal representation of that object and all of its properties.  You then use an approval test to verify that the toString() representation is exactly what you wanted it to be.  What happens when you add additional properties to that Person class?  Now your toString() method doesn't contain the updated properties and there may be some internal state information that isn't captured in your toString() method that may be important.  Even if you do happen to update your toString() method again, now you have to completely verify all of your tests containing that object because you essentially broke all of your prior Approval tests because there is a difference between your actual results, and your approved results.  This type of situation seems sloppy, and could be a big potential drawback of Approval tests.
